#![cfg(feature = "embedding")]
//! Integration tests that exercise the real ONNX-based DefaultEmbedding in end-to-end flows.

use anyhow::Result;
use seekdb_rs::{
    AddBatch, DefaultEmbedding, DistanceMetric, EmbeddingFunction, GetQuery, HnswConfig,
    IncludeField, ServerClient,
};

mod common;
use common::{load_config_for_integration, ts_suffix};

/// Use DefaultEmbedding to auto-generate embeddings when adding documents and verify shapes.
#[tokio::test]
async fn collection_add_with_auto_embedding_default_embedding() -> Result<()> {
    let Some(config) = load_config_for_integration() else {
        return Ok(());
    };

    let admin = ServerClient::from_config(config.clone()).await?;
    let db_name = format!("rs_auto_onnx_{}", ts_suffix());
    admin.create_database(&db_name, None).await?;

    let mut db_config = config.clone();
    db_config.database = db_name.clone();
    let client = ServerClient::from_config(db_config).await?;

    let coll_name = format!("auto_onnx_coll_{}", ts_suffix());

    // Construct the real ONNX-based embedding function and use its runtime dimension.
    let ef = DefaultEmbedding::new()?;
    let dim = ef.dimension() as u32;

    let hnsw = HnswConfig {
        dimension: dim,
        distance: DistanceMetric::Cosine,
    };

    let coll = client
        .create_collection::<DefaultEmbedding>(&coll_name, Some(hnsw), Some(ef))
        .await?;

    let ids = vec!["onnx1".to_string(), "onnx2".to_string()];
    let docs = vec![
        "seekdb rust integration".to_string(),
        "vector search with onnx".to_string(),
    ];

    // Auto-embedding: only documents are provided, embeddings are generated by DefaultEmbedding.
    coll.add_batch(AddBatch::new(&ids).documents(&docs))
        .await?;

    let got = coll
        .get_query(
            GetQuery::new().with_include(&[
                IncludeField::Documents,
                IncludeField::Metadatas,
                IncludeField::Embeddings,
            ]),
        )
        .await?;

    assert_eq!(got.ids.len(), ids.len());

    let docs_out = got
        .documents
        .as_ref()
        .expect("documents must be present with IncludeField::Documents");
    assert_eq!(docs_out.len(), ids.len());

    let embs = got
        .embeddings
        .as_ref()
        .expect("embeddings must be present with IncludeField::Embeddings");
    assert_eq!(embs.len(), ids.len());
    for emb in embs {
        assert_eq!(emb.len(), dim as usize);
    }

    client.delete_collection(&coll_name).await.ok();
    admin.delete_database(&db_name, None).await.ok();
    Ok(())
}

/// Use DefaultEmbedding for query_texts end-to-end, verifying the query path works with ONNX.
#[tokio::test]
async fn collection_query_texts_with_default_embedding() -> Result<()> {
    let Some(config) = load_config_for_integration() else {
        return Ok(());
    };

    let admin = ServerClient::from_config(config.clone()).await?;
    let db_name = format!("rs_qtexts_onnx_{}", ts_suffix());
    admin.create_database(&db_name, None).await?;

    let mut db_config = config.clone();
    db_config.database = db_name.clone();
    let client = ServerClient::from_config(db_config).await?;

    let coll_name = format!("qtexts_onnx_coll_{}", ts_suffix());

    let ef = DefaultEmbedding::new()?;
    let dim = ef.dimension() as u32;

    let hnsw = HnswConfig {
        dimension: dim,
        distance: DistanceMetric::Cosine,
    };

    let coll = client
        .create_collection::<DefaultEmbedding>(&coll_name, Some(hnsw), Some(ef))
        .await?;

    let ids = vec!["qt_onnx1".to_string(), "qt_onnx2".to_string()];
    let docs = vec![
        "hello rust with onnx".to_string(),
        "hello seekdb embeddings".to_string(),
    ];

    // Insert documents via auto-embedding.
    coll.add_batch(AddBatch::new(&ids).documents(&docs))
        .await?;

    let qr = coll
        .query_texts(
            &["hello rust".to_string()],
            2,
            None,
            None,
            Some(&[IncludeField::Documents, IncludeField::Metadatas]),
        )
        .await?;

    // We only check that the query succeeds and returns at least one result;
    // the exact ranking depends on the model and is not asserted here.
    assert_eq!(qr.ids.len(), 1);
    assert!(
        !qr.ids[0].is_empty(),
        "expected at least one result from query_texts with DefaultEmbedding"
    );

    client.delete_collection(&coll_name).await.ok();
    admin.delete_database(&db_name, None).await.ok();
    Ok(())
}
